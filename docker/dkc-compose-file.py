#!/usr/bin/env python3
"""
Docker Compose project detection.
Handles all the ways Docker Compose can be configured.

Requirements
------------
❯ PIP_REQUIRE_VIRTUALENV= pip3 install --break-system-packages --user pyyaml
Collecting pyyaml
  Using cached PyYAML-6.0.2-cp313-cp313-macosx_11_0_arm64.whl.metadata (2.1 kB)
Using cached PyYAML-6.0.2-cp313-cp313-macosx_11_0_arm64.whl (171 kB)
Installing collected packages: pyyaml
Successfully installed pyyaml-6.0.2

AI Warning
----------
2025-07-10 Generated by Claude Sonnet 4. I didn't read all code over; Just fixing unexpected behavior as bugs come up.
Prompt:
- What is a reliable way to check if the current directory is a docker-compose project root?
- I need something more thorough.  For example, I have a Seafile project that contains a  .env that defines COMPOSE_FILE pointing to files that have names different from the common docker-compose.yml or compose.yml
I need a comprehensive that guarantees that it can identify all such projects
- Does docker compose walk up the directory tree to find the root? If so, then update the script to do the same

Then, several manual fixes.
"""
# /// script
# requires-python = ">=3.9"
# dependencies = [
#   "pyyaml",
# ]
# ///

import os
import re
import yaml
from pathlib import Path
from typing import List, Optional, Dict, Any
import logging

class DockerComposeDetector:
    """Comprehensive Docker Compose project detector."""

    # Standard compose file names (in order of precedence)
    STANDARD_COMPOSE_FILES = [
        'compose.yaml',
        'compose.yml',
        'docker-compose.yaml',
        'docker-compose.yml'
    ]

    # Override files that indicate compose usage
    OVERRIDE_PATTERNS = [
        'compose.override.yaml',
        'compose.override.yml',
        'docker-compose.override.yaml',
        'docker-compose.override.yml',
        'docker-compose.*.yaml',
        'docker-compose.*.yml'
    ]

    def __init__(self, path: str = '.', debug: bool = False, traverse_up: bool = True):
        self.path = Path(path).resolve()
        self.debug = debug
        self.traverse_up = traverse_up
        if debug:
            logging.basicConfig(level=logging.DEBUG)

    def detect(self) -> Dict[str, Any]:
        """
        Comprehensive detection of Docker Compose projects.
        Returns detailed information about the project structure.
        """
        result = {
            'is_compose_project': False,
            'compose_files': [],
            'env_files': [],
            'override_files': [],
            'compose_file_env_var': None,
            'compose_path_env_var': None,
            'detection_methods': [],
            'project_root': None
        }

        # If traverse_up is enabled, find the actual project root:
        # - Starts from the specified directory
        # - Walks up parent directories until finding:
        #   - Standard compose files (compose.yaml, docker-compose.yml, etc.)
        #   - .env files with COMPOSE_FILE variables
        #   - Override files (compose.override.yml, etc.)
        # - Stops at filesystem root if nothing found
        # - Uses the found project root for all subsequent detection methods
        if self.traverse_up:
            project_root = self._find_project_root()
            if project_root:
                result['project_root'] = str(project_root)
                # Update our working path to the project root
                original_path = self.path
                self.path = project_root
                if self.debug:
                    logging.debug(f"Found project root at: {project_root}")
            else:
                result['project_root'] = str(self.path)
        else:
            result['project_root'] = str(self.path)

        # Method 1: Check for standard compose files
        standard_files = self._find_standard_compose_files()
        if standard_files:
            result['compose_files'].extend(standard_files)
            result['detection_methods'].append('standard_filenames')
            result['is_compose_project'] = True

        # Method 2: Check .env files for COMPOSE_FILE variables
        env_compose_files = self._check_env_files()['files']
        if env_compose_files:
            result['compose_files'].extend(env_compose_files['files'])
            result['env_files'].extend(env_compose_files['env_files'])
            result['compose_file_env_var'] = env_compose_files.get('compose_file_var')
            result['compose_path_env_var'] = env_compose_files.get('compose_path_var')
            result['detection_methods'].append('env_file_variables')
            result['is_compose_project'] = True

        # Method 3: Check for override files
        override_files = self._find_override_files()
        if override_files:
            result['override_files'].extend(override_files)
            result['detection_methods'].append('override_files')
            result['is_compose_project'] = True

        # Method 4: Check environment variables
        env_vars = self._check_environment_variables()
        if env_vars:
            result['compose_files'].extend(env_vars.get('files', []))
            result['compose_file_env_var'] = env_vars.get('compose_file_var')
            result['compose_path_env_var'] = env_vars.get('compose_path_var')
            result['detection_methods'].append('environment_variables')
            result['is_compose_project'] = True

        # Method 5: Content analysis - look for compose-like YAML structure
        if not result['is_compose_project']:
            yaml_files = self._analyze_yaml_content()
            if yaml_files:
                result['compose_files'].extend(yaml_files)
                result['detection_methods'].append('yaml_content_analysis')
                result['is_compose_project'] = True

        # Remove duplicates and validate files exist (preserve order)
        result['compose_files'] = list(dict.fromkeys(f for f in result['compose_files'] if self._file_exists(f)))
        result['override_files'] = list(dict.fromkeys(f for f in result['override_files'] if self._file_exists(f)))

        # If we changed the working path, restore it
        if self.traverse_up and 'original_path' in locals():
            self.path = original_path

        return result

    def _find_project_root(self) -> Optional[Path]:
        """
        Find the Docker Compose project root by traversing up the directory tree.
        Mimics Docker Compose's behavior of looking for compose files in parent directories.
        """
        current_path = self.path

        # Traverse up the directory tree until we find a compose file or reach the root
        while current_path != current_path.parent:
            # Check for standard compose files
            for filename in self.STANDARD_COMPOSE_FILES:
                compose_file = current_path / filename
                if compose_file.exists():
                    if self.debug:
                        logging.debug(f"Found compose file while traversing up: {compose_file}")
                    return current_path

            # Check for .env files with COMPOSE_FILE variables
            env_files = [current_path / '.env']
            env_files.extend(current_path.glob('.env.*'))

            for env_file in env_files:
                if env_file.exists():
                    try:
                        with open(env_file, 'r') as f:
                            content = f.read()
                            if re.search(r'^COMPOSE_FILE=', content, re.MULTILINE):
                                if self.debug:
                                    logging.debug(f"Found COMPOSE_FILE in .env while traversing up: {env_file}")
                                return current_path
                    except (IOError, UnicodeDecodeError):
                        continue

            # Check for override files
            override_found = False
            for pattern in self.OVERRIDE_PATTERNS:
                if '*' in pattern:
                    matches = list(current_path.glob(pattern))
                    if matches:
                        override_found = True
                        break
                else:
                    if (current_path / pattern).exists():
                        override_found = True
                        break

            if override_found:
                if self.debug:
                    logging.debug(f"Found override files while traversing up: {current_path}")
                return current_path

            # Move up one directory
            current_path = current_path.parent

        # If we reach here, no project root was found
        return None

    def _find_standard_compose_files(self) -> List[str]:
        """Find standard Docker Compose files."""
        found_files = []
        for filename in self.STANDARD_COMPOSE_FILES:
            filepath = self.path / filename
            if filepath.exists():
                found_files.append(str(filepath))
                if self.debug:
                    logging.debug(f"Found standard compose file: {filepath}")
        return found_files

    def _check_env_files(self) -> Dict[str, Any]:
        """Check .env files for COMPOSE_FILE and COMPOSE_PATH_SEPARATOR variables."""
        result = {'files': [], 'env_files': []}

        # Check various .env file patterns
        env_patterns = ['.env', '.env.local', '.env.*.local', '.env.*']
        env_files = []

        for pattern in env_patterns:
            if '*' in pattern:
                env_files.extend(self.path.glob(pattern))
            else:
                env_file = self.path / pattern
                if env_file.exists():
                    env_files.append(env_file)

        for env_file in env_files:
            try:
                with open(env_file, 'r') as f:
                    content = f.read()
                    result['env_files'].append(str(env_file))

                    # Look for COMPOSE_FILE variable
                    compose_file_match = re.search(r'^COMPOSE_FILE=(.+)$', content, re.MULTILINE)
                    if compose_file_match:
                        compose_files = compose_file_match.group(1).strip('\'"')
                        result['compose_file_var'] = compose_files

                        # Handle multiple files separated by : or ;
                        separator = ':'
                        if 'COMPOSE_PATH_SEPARATOR' in content:
                            sep_match = re.search(r'^COMPOSE_PATH_SEPARATOR=(.+)$', content, re.MULTILINE)
                            if sep_match:
                                separator = sep_match.group(1).strip('\'"')
                                result['compose_path_var'] = separator

                        files = [f.strip() for f in compose_files.split(separator) if f.strip()]
                        for file in files:
                            # Handle relative paths
                            if not os.path.isabs(file):
                                file = str(self.path / file)
                            result['files'].append(file)

                        if self.debug:
                            logging.debug(f"Found COMPOSE_FILE in {env_file}: {files}")

            except (IOError, UnicodeDecodeError) as e:
                if self.debug:
                    logging.debug(f"Could not read {env_file}: {e}")
                continue

        return result

    def _find_override_files(self) -> List[str]:
        """Find Docker Compose override files."""
        found_files = []

        for pattern in self.OVERRIDE_PATTERNS:
            if '*' in pattern:
                matches = list(self.path.glob(pattern))
                found_files.extend(str(m) for m in matches)
            else:
                filepath = self.path / pattern
                if filepath.exists():
                    found_files.append(str(filepath))

        if self.debug and found_files:
            logging.debug(f"Found override files: {found_files}")

        return found_files

    def _check_environment_variables(self) -> Optional[Dict[str, Any]]:
        """Check system environment variables for Docker Compose configuration."""
        result = {'files': []}

        # Check COMPOSE_FILE environment variable
        compose_file_env = os.environ.get('COMPOSE_FILE')
        if compose_file_env:
            result['compose_file_var'] = compose_file_env
            separator = os.environ.get('COMPOSE_PATH_SEPARATOR', ':')
            result['compose_path_var'] = separator

            files = [f.strip() for f in compose_file_env.split(separator) if f.strip()]
            for file in files:
                if not os.path.isabs(file):
                    file = str(self.path / file)
                result['files'].append(file)

            if self.debug:
                logging.debug(f"Found COMPOSE_FILE env var: {files}")

        return result if result['files'] else None

    def _find_standard_compose_files(self) -> List[str]:
        """Analyze YAML files for Docker Compose structure."""
        compose_files = []

        # Look for any YAML files in the directory
        yaml_files = list(self.path.glob('*.yml')) + list(self.path.glob('*.yaml'))

        for yaml_file in yaml_files:
            try:
                with open(yaml_file, 'r') as f:
                    content = yaml.safe_load(f)

                if self._is_compose_like_yaml(content):
                    compose_files.append(str(yaml_file))
                    if self.debug:
                        logging.debug(f"Detected compose-like YAML: {yaml_file}")

            except (yaml.YAMLError, IOError, UnicodeDecodeError):
                continue

        return compose_files

    def _analyze_yaml_content(self) -> List[str]:
        """Analyze YAML files for Docker Compose structure."""
        compose_files = []

        # Look for any YAML files in the directory
        yaml_files = list(self.path.glob('*.yml')) + list(self.path.glob('*.yaml'))

        for yaml_file in yaml_files:
            try:
                with open(yaml_file, 'r') as f:
                    content = yaml.safe_load(f)

                if self._is_compose_like_yaml(content):
                    compose_files.append(str(yaml_file))
                    if self.debug:
                        logging.debug(f"Detected compose-like YAML: {yaml_file}")

            except (yaml.YAMLError, IOError, UnicodeDecodeError):
                continue

        return compose_files

    def _is_compose_like_yaml(self, content: Any) -> bool:
        """Check if YAML content looks like a Docker Compose file."""
        if not isinstance(content, dict):
            return False

        # Check for typical compose structure
        compose_indicators = [
            'services',  # Most common
            'version',   # Older format
            'networks',  # Compose feature
            'volumes',   # Compose feature
            'secrets',   # Compose feature
            'configs'    # Compose feature
        ]

        # Need at least 'services' or 'version' + one other indicator
        has_services = 'services' in content
        has_version = 'version' in content
        other_indicators = sum(1 for key in compose_indicators[2:] if key in content)

        return has_services or (has_version and other_indicators > 0)

    def _file_exists(self, filepath: str) -> bool:
        """Check if a file exists."""
        return Path(filepath).exists()

    def is_compose_project(self) -> bool:
        """Simple boolean check if directory is a Docker Compose project."""
        return self.detect()['is_compose_project']

    def get_compose_files(self) -> List[str]:
        """Get list of compose files for this project."""
        return self.detect()['compose_files']


def main():
    """CLI interface for the detector."""
    import argparse
    import sys

    parser = argparse.ArgumentParser(description='Detect Docker Compose projects')
    parser.add_argument('path', nargs='?', default='.', help='Path to check (default: current directory)')
    parser.add_argument('--debug', action='store_true', help='Enable debug output')
    parser.add_argument('--json', action='store_true', help='Output as JSON')
    parser.add_argument('-q', '--quiet', action='store_true',
                       help='Quiet mode: print compose file paths if found, otherwise exit with non-zero code')
    parser.add_argument('--no-traverse', action='store_true',
                       help='Don\'t traverse up directory tree (only check specified directory)')

    args = parser.parse_args()

    detector = DockerComposeDetector(args.path, debug=args.debug, traverse_up=not args.no_traverse)
    result = detector.detect()

    # Determine exit code based on whether project was found
    exit_code = 0 if result['is_compose_project'] else 1

    if args.quiet:
        if result['compose_files']:
            for file in result['compose_files']:
                print(file)
    elif args.json:
        import json
        print(json.dumps(result, indent=2))
    else:
        if result['is_compose_project']:
            print(f"✓ Docker Compose project detected")
            if result['project_root'] != str(detector.path):
                print(f"  Project root: {result['project_root']}")
                print(f"  Started from: {detector.path}")
            else:
                print(f"  Project root: {result['project_root']}")
            print(f"  Detection methods: {', '.join(result['detection_methods'])}")
            if result['compose_files']:
                print(f"  Compose files: {', '.join(result['compose_files'])}")
            if result['override_files']:
                print(f"  Override files: {', '.join(result['override_files'])}")
            if result['env_files']:
                print(f"  Environment files: {', '.join(result['env_files'])}")
        else:
            print(f"✗ No Docker Compose project detected in {detector.path} or parent directories")

    sys.exit(exit_code)


if __name__ == '__main__':
    main()
